<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>软件设计 on i-cooltea的博客</title>
    <link>http://i-cooltea.github.io/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/</link>
    <description>Recent content in 软件设计 on i-cooltea的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 24 Oct 2017 15:28:00 +0000</lastBuildDate>
    
	<atom:link href="http://i-cooltea.github.io/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>MVC设计思想</title>
      <link>http://i-cooltea.github.io/posts/mvc%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</link>
      <pubDate>Tue, 24 Oct 2017 15:28:00 +0000</pubDate>
      
      <guid>http://i-cooltea.github.io/posts/mvc%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</guid>
      <description>MVC设计思想   MVC英文即Model-View-Controller，  这样一个应用被分成三个层——模型层、视图层、控制层。  使用这种设计的思想能够将复杂的程序 分解成各个小的模块,实现程序的解耦和提高程序的可扩展性        视图(View)    视图(View)代表用户交互界面，对于Web应用来说， 可以概括为HTML界面。随着应用的复杂性和规模性，  界面的处理也变得具有挑战性。一个应用可能有很多不同的视图，  MVC设计模式对于视图的处理仅限于视图上数据的采集和处理，以及用户的请求，而不包括在视图上的业务流程的处理。  模型(Model)    模型(Model)：就是业务流程/状态的处理以及业务规则的制定。业务流程的处理过程对其它层来  说是黑箱操作，对一个开发者来说，就可以专注于业务模型的设计。    业务模型还有一个很重要的模型那就是数据模型。数据模型主要指实体对象的数据 保存（持续化）。  比如将一张订单保存到数据库，从数据库获取订单。我们可以将这个模型单独列出,  所有有关数据库的操作只限制在该模型中。    控制(Controller)    控制(Controller)可以理解为从View和Model中间的桥梁.  用户接收请求, 将模型与视图匹配在一起，共同完成用户的请求。  划分控制层的作用也很明显，它清楚地告诉你，它就是一个分发器，选择什么样的模型，  选择什么样的视图,可以完成什么样的用户请求。控制层并不做任何的数据处理。    例如，用户点击一个连接，控制层接受请求后, 并不处理业务信息，它只把用户的信息传递给模型，  告诉模型做什么，选择符合要求的视图返回给用户。因此，一个模型可能对应多个视图，一个视图可  能对应多个模型。  模型、视图与控制器的分离，使得一个模型可以具有多个显示视图。如果用户通过某个视图的控制器改变了模型的数据，所有其它依赖于这些数据的视图都应反映到这些变化。因此，无论何时发生了何种数据变化，控制器都会将变化通知所有的视图，导致显示的更新。这实际上是一种模型的变化-传播机制。模型、视图、控制器三者之间的关系和各自的主要功能.      MVC的优点  大部分用过程语言比如ASP、PHP开发出来的Web应用，初始的开发模板就是混合层的数据编程。例如，直接向数据库发送请求并用HTML显示,开发速度往往比较快,但由于数据页面的分离不是很直接,因而很难体现出业务模型的样子或者模型的重用性。产品设计弹性力度很小，很难满足用户的变化性需求。MVC要求对应用分层，虽然要花费额外的工作，但产品的结构清晰，产品的应用通过模型可以得到更好地体现。      首先，最重要的是应该有多个视图对应一个模型的能力。在目前用户需求的快速变化下，可能有多种方式访问应用的要求。例如，订单模型可能有本系统的订单，也有网上订单，或者其他系统的订单，但对于订单的处理都是一样，也就是说订单的处理是一致的。按MVC设计模式，一个订单模型以及多个视图即可解决问题。这样减少了代码的复制，即减少了代码的维护量，一旦模型发生改变，也易于维护。    其次，由于模型返回的数据不带任何显示格式，因而这些模型也可直接应用于接口的使用。    再次，由于一个应用被分离为三层，因此有时改变其中的一层就能满足应用的改变。一个应用的业务流程或者业务规则的改变只需改动MVC的模型层- 控制层的概念也很有效，由于它把不同的模型和不同的视图组合在一起完成不同的请求，因此，控制层可以说是包含了用户请求权限的概念。    最后，它还有利于软件工程化管理。由于不同的层各司其职，每一层不同的应用具有某些相同的特征，有利于通过工程化、工具化产生管理程序代码。    MVC的不足  MVC的不足体现在以下几个方面：  （1）增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。  （2）视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。  （3）视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。  （4） 目前，一般高级的界面工具或构造器不支持MVC架构。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成使用MVC的困难。</description>
    </item>
    
  </channel>
</rss>